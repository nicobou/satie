TITLE:: SATIE Spatializers
SUMMARY:: Overview of spatialization plugins in SATIE
CATEGORIES:: Libraries>SATIE, Libraries>HOA, UGens > Multichannel > Panners
RELATED:: Overview/SATIE-Overview, Classes/SpatializerPlugin, Examples/Ambi

Go back to link::Overview/SATIE-Overview::

Previous Section: link::Examples/SATIE-Basics::

Next Section: link::Examples/Processes::


SECTION:: Overview

SATIE provides two types of spatializers: VBAP and higher order ambisonics (up to the 5th order). The lists of available plugins in each category follows:

SUBSECTION:: VBAP spatializers

TABLE::
##  STRONG::Name::|| STRONG::Number of channels::||STRONG::Description::
##  exaVBAP || 6 || 6 channel ring (2D)
##  _1474_VBAP || 16 || 16 channel dome (IEM)
##  emptySpat || 0 || No spat. Expect nothing.
##  dodecVBAP || 20 || 20 channel layout (3D)
##  domeVBAP || 31 || 31 channel sphere (SAT dome)
##  labodomeVBAP || 24 || 24 channel speaker layout on a sphere (minidome at the SAT)
##  stereoPanner || nil || Another stereo panner (use stereoListener)
##  stereoListener || 2 || A stereo panner
##  headphoneListener || 2 || a stereo listener with near-field rendering
##  cube || 8 || 8 channel 3D layout (Cube corners)
##  monoSpat || 1 || Mono spat
##  iaiaVBAP || 24 || 24 channel speaker layout on a sphere (digital dome at IAIA)
##  octoVBAP || 8 || 8 channel ring (2D)
::

SUBSECTION:: HOA Plugins

HOA plugins make use the SC-HOA quark by Florian Grond.

SUBSECTION:: HOA Spatializers
TABLE::
## STRONG::Name:: || STRONG::Description::
##  Satosphere || Satosphere ambisonic decoder
##  Binaural26 || Binaural decoder based on Lebedev26
##  Binaural06 || Binaural decoder based on Lebedev06
::

SUBSECTION:: HOA Processing plugins

Besides ambisonic spatializers, HOA plugins also include processors specific for b-format signals.

TABLE::
## STRONG::Name:: || STRONG::Description::
##  Rotate || Rotate the sound field (args in degree from -180 to 180)
##  BeamDirac || Filters along a specifed direction (truncated Dirac). Az from -180 to 180, ele from -90 to 90
##  BeamCardio || Filters along a specifed direction (hyper cardioid pattern). Az from -180 to 180, ele from -90 to 90. Hyper cardioid pattern from 1 to 3.
##  Mirror || Mirror soundfield
##  RotateAz || Rotation around the z-axis (angle from -180 to 180)
::

SECTION:: Test your setup

We use this utility code to test various speaker setups before doing any spatialization:

CODE::
(
// DAC tester
//    to stop without gui
//		~task.stop;
//		~dacTestSyn.release;

~panDur=0.4;
~usingServer = "Built-in Output"; // OSX only

~channelCount= Server.local.options.numOutputBusChannels;

if  ( ~channelCount == 32,
	{
		~channelCount= ~channelCount-1;
});


SynthDef(\speakerMapTest, { |out, gate=1|
    Out.ar(out, WhiteNoise.ar(1) * EnvGen.kr(Env.asr(0.03, 0.3, 0.01), gate, doneAction:2));
}).store(); // use store for compatibility with pattern example below

~task= Task({
    loop {
		~channelCount .do({ arg item;
			~dacTestSyn = Synth(\speakerMapTest, [\out, item]); // play out through hardware output bus 0 (see Out.help)
            ~panDur.wait;
			~dacTestSyn.release;
        });
    }
});

~rebootServerUsing = {
	Platform.case(
		\osx, {
			var deviceName = ~usingServer;
			deviceName.postln;
			Server.local.options.device = deviceName;
			("booting with: "++deviceName).postln;
		});
	Server.local.options.numOutputBusChannels = ~channelCount;
	s.reboot;
    ("THE SERVER IS :  "++s).postln;
    Server.allRunningServers.postln;
};

// UI
~dacTestWindow=Window.new("dac testing", Rect(30, 30, 400, 130)).front;
~dacTestWindow.view.decorator=FlowLayout(~dacTestWindow.view.bounds);
~dacTestWindow.view.decorator.gap=8@2;


~stateButton = Button(~dacTestWindow, 75 @ 30);
~stateButton.states = [
    ["Start", Color.black, Color.green(0.7)],
    ["Stop", Color.white, Color.red(0.7)]
];

~stateButton.action = { |view|
	view.value.postln;

	if (view.value == 1, {
		~task.play;
	},
	//else stop
	{
		~task.stop;
		~dacTestSyn.release;
	});

};

~testWindButton = Button(~dacTestWindow, 120 @ 30);
~testWindButton.states = [
	["view checkboxes", Color.white, Color.gray],
	["view checkboxes", Color.white, Color.gray]
];

~testWindButton.action = { |view|
	view.value.postln;

	if (view.value == 1, {
		 ~genSpeakerTestWindow.value(~channelCount);
	},
	//else stop
	{
		 ~genSpeakerTestWindow.value(~channelCount);

	});

};

~chanCountSlider = EZSlider(~dacTestWindow, 380@20, "channels", ControlSpec(0, 31, \lin, 1, ~channelCount));
~chanCountSlider.action_({ |ez| (  ~channelCount = ez.value;   )});

~panDurSlider = EZSlider(~dacTestWindow, 380@20, "panDuration", ControlSpec(0.05, 2, \lin, 0.02, 0.4));
~panDurSlider.action_({ |ez| (  ~panDur = ez.value;   )});

g = EZPopUpMenu.new(~dacTestWindow,250@30 ,"Device : ");

Button.new(~dacTestWindow,Rect(10,10,120,30)).states_([["reboot server"]]).action_(~rebootServerUsing);

Platform.case (
	\osx, {
		z=0;
		ServerOptions.outDevices.do({ arg key ;
			var index = z;
			//postf("dev: "++z++"  "++key.asSymbol++"\n");
			g.addItem(key.asSymbol, { |a| ( ~usingServer= ServerOptions.outDevices[index] ) });
			z=z+1;
		});
	}
);

// speaker test window

~speakerTestWindow=nil;
~genSpeakerTestWindow = { | speakerCount |
	var w, b;

	if ( ~speakerTestWindow == nil,
		{
			~speakerTestArray = Array.fill(speakerCount,'');
			w = GUI.window.new( "Test Outputs", Rect( 128, 64, 380, 108 ));

			w.view.decorator = FlowLayout( w.view.bounds );
			w.view.background = Color.black;

			w.onClose_({ ~killSynths.value() }); //close the window and the synth plays

			speakerCount.do({ arg i;
				b = GUI.button.new( w, Rect( rrand( 20, 300 ), rrand( 20, 300 ), 30, 30 ));
				b.states = [[ i.asSymbol, Color.white, Color.gray ],
					[ i.asSymbol, Color.white, Color.red ]];

				b.action = { |view|
					var index = i;
					if (view.value == 1, {
						~speakerTestArray.put(index, Synth(\speakerMapTest, [\out, index]));
					},
					//else stop
					{
						~speakerTestArray.at(index) .free
					});
				};
			});
			~speakerTestWindow = w;
	});
	~speakerTestWindow.front;
};

~killSynths = {
	"KILLING ALL SYNTHS".postln;

	~speakerTestArray.do({arg item;
		if ( item!=nil, { item.free});
		~speakerTestWindow = nil;
	});

};
)
::


Go back to link::Overview/SATIE-Overview::

Previous Section: link::Examples/SATIE-Basics::

Next Section: link::Examples/Processes::

