TITLE:: Processes
summary:: Introduction to SATIE processes
categories:: Libraries>SATIE

Go back to link::Overview/SATIE-Overview::

Previous Section: link::Examples/Spatializers::

Next Section: link::Examples/Effects::


SECTION:: Overview

Processes allow more complex behaviors while limiting OSC communications between 3D engine and SATIE server. Processes are arbitrary routines and could be associated with particle systems, granular-type sound events, patterns, sequences, but are not limited to generating sound (or other events) could also be used for introspection, tracking of various interaction or sound features and reporting. The process will run completely independent of the 3D engine control via OSC, unless appropriate methods have been implemented or overriden.

SECTION:: Simple process example

We start with setting up SATIE. The synths that will be used by the process must be compiled on the server:

code::
(
s = Server.supernova.local;
~satieConfiguration = SatieConfiguration.new(s, [\stereoListener]);
~satie = Satie.new(~satieConfiguration);
~satie.boot();
s.waitForBoot({
	s.makeGui;
	s.plotTree;
})
)
::

And we define the process. The process needs to be encapsulated in an environment and must implement soft::setup:: and soft::cleanup:: methods. These methods are being used in OSC handlers. See OSC API to see which methods could be implemented to have some control over process via OSC.

code::
(
//process definition
~helloProcess = Environment.make({
	// public
	~group = \default; // enables operations on group
	~interval = 0.5;
	~items = 10;

	// private
	~routine;

	~makeRoutine = { |self, nodeName |
		self.routine = Routine {
			// Here the routine creates sound objects without deleting them util the routine is stopped.
			loop {
				self.items.do({|item|
					var nodename = nodeName ++ "_" ++item;
					var synth;
					var note;
					var elev = Prand([-90, -60, 30, 0, 90]).asStream;
					var idx = 0;
					note = rrand(60, 63);
					// Kamikaze is a special case of synth generated by SATIE:
					// it dies when its envelope falls to silence
					synth = ~satie.makeKamikaze(nodename.asSymbol, \zkarpluck1, self.group);
					synth.set(
						\t_trig, 1,
						\gainDB, rrand(-40, -30),
						\note, [note, 1, 0.5],
						\aziDeg, rrand(-180,180),
						\spread, 0,
						\eleDeg, elev.next
					);
					self.interval.wait;
				});
			}
		};
	};
	~start = { | self | self.routine.reset; self.routine.play };

	// setup and cleanup methods are mandatory, particularly for use via OSC
	// setup method should expect at least two arguments: name of the process and group.
	~setup = { | self, nodeName, groupName |
		self.group = groupName.asSymbol;
		self.makeRoutine(nodeName.asSymbol);
		self.start;
	};
	~cleanup = { | self | self.routine.stop;};
});
// ~helloProcess.know=true;
)
::

code::
// register the process with SATIE
~process = ~satie.makeProcess(\testProcess, ~helloProcess);
// instantiate the process. It will automatically execute its setup() method.
// it will also create a unique group for audio sources
// it will also register it with Satie in processInstances dictionary
~satie.makeProcessInstance(\myProcess, \testProcess);
::

Finally, we can execute process methods by accessing the running process through the instance dictionary
code::
(
~satie.processInstances[\myProcess].cleanup;
~satie.processInstances[\myProcess].start;
~satie.processInstances[\myProcess].cleanup;
)
::


Go back to link::Overview/SATIE-Overview::

Previous Section: link::Examples/Spatializers::

Next Section: link::Examples/Effects::

