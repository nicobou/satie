




// this file defines  a process class, which is ONLY used by source nodes that have that have a URI of type:   "process" , e.g:      uri://process  "raindrops1"
// you can define any number of these process clases, each one, corresponding to a particular type of processing  behavoir you define

// this class is kamakazie instances, generated by the "trigger" call,  with only i-tome spatializer update

//  FOR USE WITH SYNTHDEFS that generate delayed random offsets for clones

// required:  set up class struct

~raindrops1= Environment[
	// required fields
	'nodeName' -> \nil,
	'nodeGroupName' -> \nil,
	'nodeGroup' -> \nil,


	// project specific
	//'cloneVector' -> [],  // vector to store allocated synths
	'debugFlag' -> 0,
	'synthRootName' -> "drops-*.wav:k:rev".asString,  // root synthedef name with wildCard for number
	'rootNameSynthdefCount' -> 100,     // number of synthDefs corresponding to the RootName,  ranging from 0 to 99:   e.g.   from  "drops-0.wav:k:rev" to "drops-99.wav:k:rev"
	'kCount' -> 0,
	'randPitchOffset' -> 0,
	'randPitchRange' -> 0.25,
	// other state,
    'spread' -> 0,  // register used for kamikazi instantiation
	'pitchSeqGlobalMode' -> 0,
	'pitchSeqSym' -> \default,
	'pitchSeqLen' -> 1,   // not used
	'pitchSeqIncr' -> 1,   // used, but only to set global sequencer state
	'pitchSeqPos' -> 0,     // not used
	// playback state
	'transposition' -> 0,
	'synthCountMax' ->  200,    //to be safe,  this value should be half of the number that breaks the server

];

// required: set these variables to the process name;
~processName = \raindrops1;
~process = ~raindrops1;
~process.know=true;


if (~satie4unity == nil, {
	error(~processName ++ ": ~satie4unity protocol undefined, can't register this process");
}, // else
{
	// if already registered, re-register
	if (  ~satie4unity.allProcesses.includesKey(~processName) == true,
		{
			inform("un-registering process: "++~processName);
			~satie4unity.allProcesses.removeAt(~processName);
	});

	inform("registering process: "++~processName);
	~satie4unity.allProcesses.put(~processName, ~process);
});


// set up class instance dictionary

~raindrops1_instances = Dictionary.new();

// define any custom "class"  variables, referenced by all "instants"  of "raindrops1" class
if (~raindrops1_pitchSequences == nil,
	{
		~raindrops1_pitchSequences = Dictionary.new();
		~raindrops1_pitchSequences.put(\default, Dictionary.new());
		~raindrops1_pitchSequences.at(\default).put(\pitches, [60]);
		~raindrops1_pitchSequences.at(\default).put(\pos, 0);
		~raindrops1_pitchSequences.at(\default).put(\incr,1);
		~raindrops1_pitchSequences.at(\default).put(\size,1);

});

// required functions

~raindrops1.cleanup = { | self |

	var synth;

	// add code here to manage project-specific stuff
	postf("~raindrops1.clearSynths: clearing synths in node: % group \n", self.nodeName);
	// var nodename=(self.nodeName++"_"++item).asSymbol;
	// ~satie.cleanInstance(nodename.asSymbol, self.nodeGroupName);
	// });
	~raindrops1_instances.removeAt(self.nodeName);
};


// required function but adaptable to project specifics
// generates N synths
~raindrops1.setup = { | self, nodeName, nodeGroupName, argsList  |
	var thisGroup = ~satie.satieGroups[nodeGroupName.asSymbol] ;

	self.nodeName = nodeName;
	self.nodeGroupName = nodeGroupName;
	self.nodeGroup = thisGroup;
	//'raindrops1,setup'.postln;

	// project-specific parsing of args string (coming from setUri OSC message string)
	//	if ( argsList.size >= 2,
	//		{
	//			//~sheefaVec = argvec;
	//
	//			// postf(" raindrops1.setup: node: %    args:   %    size:  %\n", nodeName, argsList, argsList.size);
	//			if ( argsList[0].asString == "cloneCount",
	//				{
	//					self.cloneCount = argsList[1].asInt.clip(1, 1000);   // clip to 1000 to avoid meltdown caused by error
	//					postf(" raindrops1.setup: node: %   setting up for % kamakazi clones \n", nodeName, self.cloneCount);
	//				},
	//				// else bad arg
	//				{
	//					error("raindrops1.setup: unrecognized key, expecting 'cloneCount' ");
	//			});
	//	});


	self[\properties] =  Dictionary.new();  // set up state register for synthfef properties

	~raindrops1_instances.put(self.nodeName.asSymbol, self);
};


// end of required class functions

// end of required class functions


// the functions below are not requied
// however if defined, they will be called by satie4unity


// if defined, will be called when node's "update" message is received
// otherwise satie4unity will send the  "update" message to the node's group
~raindrops1.updateConnection = { | self, aziDeg, eleDeg, gainDB, delayMs, lpHz, distance |

	// do nothing for this node, since spatialization is done using the trigger method
};

// if defined, will be called when node's "spread" message is received
// otherwise the "spread" message will be applided to the node's group
~raindrops1.spread = { | self, spreadVal |

    self.spread = spreadVal;
	//postf("spread message:  val:% \n", spreadVal);
};


// if defined, will be called when node's "prop" message is received
// otherwise the "prop" message will be applided to the node's group
~raindrops1.prop = { | self, key, value |

	self[\properties].put(key, value);  // keep property state for initializing synthdefs

	//postf("prop message: key: %    val:% \n", key, value);
};


// totally custom functions.  Calls to these functions result from OSC events received by satie4unity from Unity, and then applied to these functions,  if they exist

~raindrops1.setIncrement = { arg self, items = #[1] ;

	if ( items.size != 1,
		{
			warn("~raindrops1.setIncrement:  bad item count,  takes one float arg, received: % items\n",items.size);
		},
		//else
		{
			postf("raindrops1.setIncrement:  increment = % \n", items[0].asFloat);

			if (self.pitchSeqGlobalMode != 0,
				{
					~raindrops1_pitchSequences.at(self.pitchSeqSym).put(\incr, items[0].asFloat);
				},
				// else
				{
					self.pitchSeqIncr = items[0].asFloat;
			});
	});
};


// custom method
// called with args:  // list: force, impactIncidence, aziDeg, eleDeg, gainDB, delayMs, lpHz, hpHz , distance
~raindrops1.trigger = { arg self, items = #[1,2,3,4,5,6,7,8,9] ;
	var thisGroup = self.nodeGroup;
	var seqName, pitch, position, incr, size, force, incidence;
	var aziDeg, eleDeg, gainDB, delayMs, lpHz, hpHz, distance;
	var xzDist, yDist, aziScaler, elevScaler;
	var cloneParams;

	if ( items.size != 9,
		{
			postf("~raindrops1.trigger:  bad item count, expecing '[ pitch force incidence]' , received: % items\n",items.size);
		},
		{ // else

			if (s.numSynths > (self.synthCountMax),
				{
					postf("%: ~raindrops1.trigger:  exceeding synthcount by: % items\n", self.nodeName, (s.numSynths - self.synthCountMax));
				},
				{ // else under voice limit, generate synth

					var nodename=(self.nodeName++"_"++self.kCount).asSymbol;
					var params;
					var synthParams;
					var synth, synthName;
					var scaledForce;



					self.kCount= self.kCount + 1;


					// kind of stupid ti assert thus value t wat
					// NO GROUP TX  IN THIS CASE:   thisGroup.set(\randTrigMaxMs, self.triggerIntervalMs);
					// kamakazi must be fully parameterized at creation

					// items.postln;



					seqName = self.pitchSeqSym;
					force =  items[0].asFloat;
					incidence = items[1].asFloat.abs;   // not using negative values
					aziDeg = items[2].asFloat.raddeg;
					eleDeg = items[3].asFloat.raddeg;
					gainDB = items[4].asFloat;
					delayMs = items[5].asFloat;
					lpHz = items[6].asFloat;
					hpHz = items[7].asFloat;
					distance = items[8].asFloat;


					size = ~raindrops1_pitchSequences.at(seqName.asSymbol).at(\size);

					params = [
						\randTrigMaxMs, self.triggerIntervalMs, \aziDeg, aziDeg, \eleDeg, eleDeg, \gainDB, gainDB,
						\delayMs, delayMs, \lpHz , lpHz, \hpHz, hpHz,\spread, self.spread
					];

					if ( self[\properties] != nil, { synthParams = params++ self[\properties].getPairs;}); // combine param arrays

					// if (self.pitchSeqGlobalMode != 0,
					// 	{
					//
					// 		position = ~raindrops1_pitchSequences.at(seqName.asSymbol).at(\pos);
					// 		incr = ~raindrops1_pitchSequences.at(seqName.asSymbol).at(\incr);
					// 		pitch = ~raindrops1_pitchSequences.at(seqName.asSymbol).at(\pitches)[position];
					// 		~raindrops1_pitchSequences.at(seqName.asSymbol).put(\pos,  ((position + incr) % size) );
					// 	},
					// 	// else   instance specific read
					// 	{
					// 		position = self.pitchSeqPos;
					// 		incr = self.pitchSeqIncr;
					// 		pitch = ~raindrops1_pitchSequences.at(seqName.asSymbol).at(\pitches)[position];
					// 		self.pitchSeqPos = ((position + incr) % size);
					// });

					pitch = 60 + self.randPitchOffset + rand2(self.randPitchRange);      //  -  (force * -10.0);   // center random pitch around midi60, use force to bias 28ve down.

					scaledForce =  force.clip(-1,1);
					scaledForce = (0.2) + (0.8 * abs(scaledForce));


					//cloneParams = synthParams++ [ \note, [ pitch+self.transposition, force, incidence ], \t_trig, 1 ];
					cloneParams = synthParams++ [ \note, [ pitch, scaledForce, incidence ], \t_trig, 1 ];

					//[ \note, [ pitch+self.transposition, force, incidence ]].postln;

					// random choice among the rootNameSynthdefCount synthRootName synthdefs
					synthName=self.synthRootName.asString.replace("*", rand(self.rootNameSynthdefCount).asString);

					synth = ~satie.makeKamikaze(nodename, synthName, self.nodeGroupName, cloneParams);
					// synth.set(\note, [ pitch+self.transposition, force, incidence ], \t_trig, 1);
			});
	});
};

// custom method
~raindrops1.readPitches = { arg self, items = #["/tmp"] ;

	var pitchList, seqName, file, csvmidifilePath;

	//postf("readPitches:   arg 0: % \n",  items[0] );

	if ( items.size != 1,
		{
			warn("~raindrops1.readPitches:  bad item count, expecting one filePath arg, received: % items\n",items.size);
		},
		//else
		{
			csvmidifilePath = items[0].asString;

			if (csvmidifilePath[0] != $/,
				{
					csvmidifilePath = ~satie4unity.projectDirectory++"/"++csvmidifilePath;
			});

			csvmidifilePath.postln;

			pitchList = List.new();
			seqName = csvmidifilePath.split.last;
			file = File(csvmidifilePath.standardizePath,"rb");

			// process only if pitch sequence has not yet been loaded
			if ( ~raindrops1_pitchSequences.includesKey(seqName.asSymbol),
				{

					//  file already loaded, just set instance  specific state
					postf("raindrops1.readPitches:  sequence % already loaded, skipping file load\n", seqName);
					self.pitchSeqSym = seqName.asSymbol;
					self.pitchSeqLen = ~raindrops1_pitchSequences.at(seqName.asSymbol).at(\size);
					// self.pitchSeqPos = 0;    DONT RESET READ HEAD

					// and reset sequence's global state  BUT DO NOT RESET READ HEAD
					// ~raindrops1_pitchSequences.at(seqName.asSymbol).put(\pos, 0);
					~raindrops1_pitchSequences.at(seqName.asSymbol).put(\incr, self.pitchSeqIncr);   // using instance specific state.. may overwrite


				},
				// else  read file and create pitch sequence
				{
					//postf("file % length:  %\n", csvmidifilePath, file.length);

					file.do({
						var value, event;

						value = file.getLine();

						if (value.contains("Note_on_c"),
							{
								event = value.split($,);
								pitchList.add(event[4].asInt);
						});
					});

					file.close;

					if (pitchList.size > 0,
						{
							postf("% pitches read from file %\n", pitchList.size,  csvmidifilePath);
							// add sequence to dictionary

							~raindrops1_pitchSequences.removeAt(seqName.asSymbol);   // overwrite previous

							~raindrops1_pitchSequences.put(seqName.asSymbol, Dictionary.new());
							~raindrops1_pitchSequences.at(seqName.asSymbol).put(\pitches, pitchList);
							~raindrops1_pitchSequences.at(seqName.asSymbol).put(\size, pitchList.size);
							~raindrops1_pitchSequences.at(seqName.asSymbol).put(\pos, 0);
							~raindrops1_pitchSequences.at(seqName.asSymbol).put(\incr, 1);


							//~raindrops1_pitchSequences.removeAt(seqName.asSymbol);
							//~raindrops1_pitchSequences.put(seqName.asSymbol, pitchList);
							//~raindrops1_pitchSequences.put(seqName.asSymbol,

							// set instance local state -- currently not used, but available for future deployment
							self.pitchSeqSym = seqName.asSymbol;
							self.pitchSeqLen = pitchList.size;
							self.pitchSeqPos = 0;
						},
						//else
						{
							warn("no pitches found in file: "++csvmidifilePath);
					});
			});
	});
};

/*
testing

~myFile =  "/Users/zack/Dropbox/Unity3D/projects_unity5/balljamDemoSATIE_2015_unity5/Assets/StreamingAssets/midi/pitchSequences/bjGroove.mid.mid.txt";
~raindrops1.readPitches(~myFile);
~raindrops1.pitchSeqLen;
~raindrops1.pitchSeqName;

*/
